# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

union Morph = Brand | BrandAggregator | BrandConnection | BrandConnectionCreatedAt | BrandConnectionId | BrandConnectionName | BrandConnectionPhoto | BrandConnectionUpdatedAt | BrandConnection_id | BrandGroupBy | Cart | CartAggregator | CartConnection | CartConnectionCreatedAt | CartConnectionId | CartConnectionUpdatedAt | CartConnectionUser | CartConnection_id | CartGroupBy | Category | CategoryAggregator | CategoryConnection | CategoryConnectionCreatedAt | CategoryConnectionId | CategoryConnectionName | CategoryConnectionUpdatedAt | CategoryConnection_id | CategoryGroupBy | ComponentCartCartItem | ComponentCustomerCustomer | ComponentPlacementPlacement | ComponentSaleProductDataSaleProductData | ComponentVirtualStockAvailableOnVirtualStock | Consignment | ConsignmentAggregator | ConsignmentConnection | ConsignmentConnectionCode_1c | ConsignmentConnectionCreatedAt | ConsignmentConnectionId | ConsignmentConnectionName | ConsignmentConnectionProduct | ConsignmentConnectionProductionDate | ConsignmentConnectionPublished_at | ConsignmentConnectionUpdatedAt | ConsignmentConnectionValidUntil | ConsignmentConnection_id | ConsignmentGroupBy | Contacts | Group | GroupAggregator | GroupConnection | GroupConnectionCategory | GroupConnectionCreatedAt | GroupConnectionId | GroupConnectionName | GroupConnectionUpdatedAt | GroupConnection_id | GroupGroupBy | Order | OrderAggregator | OrderConnection | OrderConnectionCreatedAt | OrderConnectionDeliveryInstruction | OrderConnectionId | OrderConnectionInvoice | OrderConnectionPoNumber | OrderConnectionRequestedShippingDate | OrderConnectionStatus | OrderConnectionUpdatedAt | OrderConnectionUser | OrderConnection_id | OrderGroupBy | Product | ProductAggregator | ProductAggregatorAvg | ProductAggregatorMax | ProductAggregatorMin | ProductAggregatorSum | ProductConnection | ProductConnectionBrand | ProductConnectionCode_1c | ProductConnectionCode_1c_uom | ProductConnectionColor | ProductConnectionCreatedAt | ProductConnectionDeletedFromSearch | ProductConnectionDescription_en | ProductConnectionDescription_ru | ProductConnectionExpectedDeliveryDate | ProductConnectionGroup | ProductConnectionId | ProductConnectionLink | ProductConnectionLongRead_en | ProductConnectionLongRead_ru | ProductConnectionMfg | ProductConnectionPhoto | ProductConnectionPn | ProductConnectionPrice_en | ProductConnectionPrice_ru | ProductConnectionSync1cDisplay | ProductConnectionUnitDimension | ProductConnectionUom | ProductConnectionUpdatedAt | ProductConnection_id | ProductGroupBy | Stock | StockAggregator | StockConnection | StockConnectionCreatedAt | StockConnectionId | StockConnectionName | StockConnectionUpdatedAt | StockConnection_id | StockGroupBy | UploadFile | UploadFileAggregator | UploadFileAggregatorAvg | UploadFileAggregatorMax | UploadFileAggregatorMin | UploadFileAggregatorSum | UploadFileConnection | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionCreatedAt | UploadFileConnectionExt | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionHeight | UploadFileConnectionId | UploadFileConnectionMime | UploadFileConnectionName | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | UploadFileConnectionSize | UploadFileConnectionUpdatedAt | UploadFileConnectionUrl | UploadFileConnectionWidth | UploadFileConnection_id | UploadFileGroupBy | UserPermissionsPasswordPayload | UsersPermissionsLoginPayload | UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsPermission | UsersPermissionsRole | UsersPermissionsRoleAggregator | UsersPermissionsRoleConnection | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionType | UsersPermissionsRoleConnection_id | UsersPermissionsRoleGroupBy | UsersPermissionsUser | UsersPermissionsUserAggregator | UsersPermissionsUserConnection | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionCart | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionCreatedAt | UsersPermissionsUserConnectionCustomerInfo | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionRole | UsersPermissionsUserConnectionUpdatedAt | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionVerifiedByAdmin | UsersPermissionsUserConnection_id | UsersPermissionsUserGroupBy | VirtualStock | VirtualStockAggregator | VirtualStockConnection | VirtualStockConnectionAddress | VirtualStockConnectionCreatedAt | VirtualStockConnectionId | VirtualStockConnectionName | VirtualStockConnectionUpdatedAt | VirtualStockConnection_id | VirtualStockGroupBy | createBrandPayload | createCartPayload | createCategoryPayload | createConsignmentPayload | createGroupPayload | createOrderPayload | createProductPayload | createRolePayload | createStockPayload | createUserPayload | createVirtualStockPayload | deleteBrandPayload | deleteCartPayload | deleteCategoryPayload | deleteConsignmentPayload | deleteContactPayload | deleteFilePayload | deleteGroupPayload | deleteOrderPayload | deleteProductPayload | deleteRolePayload | deleteStockPayload | deleteUserPayload | deleteVirtualStockPayload | updateBrandPayload | updateCartPayload | updateCategoryPayload | updateConsignmentPayload | updateContactPayload | updateGroupPayload | updateOrderPayload | updateProductPayload | updateRolePayload | updateStockPayload | updateUserPayload | updateVirtualStockPayload

type AdminUser {
    firstname: String!
    id: ID!
    lastname: String!
    username: String
}

type Brand {
    _id: ID!
    createdAt: DateTime!
    id: ID!
    name: String
    photo: UploadFile
    products(limit: Int, sort: String, start: Int, where: JSON): [Product]
    updatedAt: DateTime!
}

type BrandAggregator {
    count: Int
    totalCount: Int
}

type BrandConnection {
    aggregate: BrandAggregator
    groupBy: BrandGroupBy
    values: [Brand]
}

type BrandConnectionCreatedAt {
    connection: BrandConnection
    key: DateTime
}

type BrandConnectionId {
    connection: BrandConnection
    key: ID
}

type BrandConnectionName {
    connection: BrandConnection
    key: String
}

type BrandConnectionPhoto {
    connection: BrandConnection
    key: ID
}

type BrandConnectionUpdatedAt {
    connection: BrandConnection
    key: DateTime
}

type BrandConnection_id {
    connection: BrandConnection
    key: ID
}

type BrandGroupBy {
    _id: [BrandConnection_id]
    createdAt: [BrandConnectionCreatedAt]
    id: [BrandConnectionId]
    name: [BrandConnectionName]
    photo: [BrandConnectionPhoto]
    updatedAt: [BrandConnectionUpdatedAt]
}

type Cart {
    _id: ID!
    cartItems: [ComponentCartCartItem]
    createdAt: DateTime!
    id: ID!
    updatedAt: DateTime!
    user: UsersPermissionsUser
}

type CartAggregator {
    count: Int
    totalCount: Int
}

type CartConnection {
    aggregate: CartAggregator
    groupBy: CartGroupBy
    values: [Cart]
}

type CartConnectionCreatedAt {
    connection: CartConnection
    key: DateTime
}

type CartConnectionId {
    connection: CartConnection
    key: ID
}

type CartConnectionUpdatedAt {
    connection: CartConnection
    key: DateTime
}

type CartConnectionUser {
    connection: CartConnection
    key: ID
}

type CartConnection_id {
    connection: CartConnection
    key: ID
}

type CartGroupBy {
    _id: [CartConnection_id]
    createdAt: [CartConnectionCreatedAt]
    id: [CartConnectionId]
    updatedAt: [CartConnectionUpdatedAt]
    user: [CartConnectionUser]
}

type Category {
    _id: ID!
    createdAt: DateTime!
    groups(limit: Int, sort: String, start: Int, where: JSON): [Group]
    id: ID!
    name: String!
    updatedAt: DateTime!
}

type CategoryAggregator {
    count: Int
    totalCount: Int
}

type CategoryConnection {
    aggregate: CategoryAggregator
    groupBy: CategoryGroupBy
    values: [Category]
}

type CategoryConnectionCreatedAt {
    connection: CategoryConnection
    key: DateTime
}

type CategoryConnectionId {
    connection: CategoryConnection
    key: ID
}

type CategoryConnectionName {
    connection: CategoryConnection
    key: String
}

type CategoryConnectionUpdatedAt {
    connection: CategoryConnection
    key: DateTime
}

type CategoryConnection_id {
    connection: CategoryConnection
    key: ID
}

type CategoryGroupBy {
    _id: [CategoryConnection_id]
    createdAt: [CategoryConnectionCreatedAt]
    id: [CategoryConnectionId]
    name: [CategoryConnectionName]
    updatedAt: [CategoryConnectionUpdatedAt]
}

type ComponentCartCartItem {
    _id: ID!
    count: Int
    id: ID!
    product: Product
}

type ComponentCustomerCustomer {
    _id: ID!
    company: String
    id: ID!
    phone: String
}

type ComponentPlacementPlacement {
    _id: ID!
    balance: Int
    id: ID!
    stock: Stock
}

type ComponentSaleProductDataSaleProductData {
    _id: ID!
    count: Int
    id: ID!
    product: Product
    sellingPrice: Float
}

type ComponentVirtualStockAvailableOnVirtualStock {
    _id: ID!
    id: ID!
    virtual_stocks(limit: Int, sort: String, start: Int, where: JSON): [VirtualStock]
}

type Consignment {
    _id: ID!
    code_1c: String
    createdAt: DateTime!
    id: ID!
    name: String
    placements: [ComponentPlacementPlacement]
    product: Product
    productionDate: Date
    published_at: DateTime
    updatedAt: DateTime!
    validUntil: Date
}

type ConsignmentAggregator {
    count: Int
    totalCount: Int
}

type ConsignmentConnection {
    aggregate: ConsignmentAggregator
    groupBy: ConsignmentGroupBy
    values: [Consignment]
}

type ConsignmentConnectionCode_1c {
    connection: ConsignmentConnection
    key: String
}

type ConsignmentConnectionCreatedAt {
    connection: ConsignmentConnection
    key: DateTime
}

type ConsignmentConnectionId {
    connection: ConsignmentConnection
    key: ID
}

type ConsignmentConnectionName {
    connection: ConsignmentConnection
    key: String
}

type ConsignmentConnectionProduct {
    connection: ConsignmentConnection
    key: ID
}

type ConsignmentConnectionProductionDate {
    connection: ConsignmentConnection
    key: ID
}

type ConsignmentConnectionPublished_at {
    connection: ConsignmentConnection
    key: DateTime
}

type ConsignmentConnectionUpdatedAt {
    connection: ConsignmentConnection
    key: DateTime
}

type ConsignmentConnectionValidUntil {
    connection: ConsignmentConnection
    key: ID
}

type ConsignmentConnection_id {
    connection: ConsignmentConnection
    key: ID
}

type ConsignmentGroupBy {
    _id: [ConsignmentConnection_id]
    code_1c: [ConsignmentConnectionCode_1c]
    createdAt: [ConsignmentConnectionCreatedAt]
    id: [ConsignmentConnectionId]
    name: [ConsignmentConnectionName]
    product: [ConsignmentConnectionProduct]
    productionDate: [ConsignmentConnectionProductionDate]
    published_at: [ConsignmentConnectionPublished_at]
    updatedAt: [ConsignmentConnectionUpdatedAt]
    validUntil: [ConsignmentConnectionValidUntil]
}

type Contacts {
    _id: ID!
    address: String
    createdAt: DateTime!
    email: String
    id: ID!
    phone: String
    published_at: DateTime
    updatedAt: DateTime!
}

type Group {
    _id: ID!
    category: Category
    createdAt: DateTime!
    id: ID!
    name: String
    products(limit: Int, sort: String, start: Int, where: JSON): [Product]
    updatedAt: DateTime!
}

type GroupAggregator {
    count: Int
    totalCount: Int
}

type GroupConnection {
    aggregate: GroupAggregator
    groupBy: GroupGroupBy
    values: [Group]
}

type GroupConnectionCategory {
    connection: GroupConnection
    key: ID
}

type GroupConnectionCreatedAt {
    connection: GroupConnection
    key: DateTime
}

type GroupConnectionId {
    connection: GroupConnection
    key: ID
}

type GroupConnectionName {
    connection: GroupConnection
    key: String
}

type GroupConnectionUpdatedAt {
    connection: GroupConnection
    key: DateTime
}

type GroupConnection_id {
    connection: GroupConnection
    key: ID
}

type GroupGroupBy {
    _id: [GroupConnection_id]
    category: [GroupConnectionCategory]
    createdAt: [GroupConnectionCreatedAt]
    id: [GroupConnectionId]
    name: [GroupConnectionName]
    updatedAt: [GroupConnectionUpdatedAt]
}

type Mutation {
    addToCart(count: Int, productId: ID!): Cart!
    changeProductCountInCart(count: Int!, productId: ID!): Cart!
    createBrand(input: createBrandInput): createBrandPayload
    createCart(input: createCartInput): createCartPayload
    createCategory(input: createCategoryInput): createCategoryPayload
    createConsignment(input: createConsignmentInput): createConsignmentPayload
    createGroup(input: createGroupInput): createGroupPayload
    createOrder(input: createOrderInput): createOrderPayload
    createOrderFromCart(deliveryInstruction: String, poNumber: String, region: String!, requestedShippingDate: String): Order!
    createProduct(input: createProductInput): createProductPayload
    "Create a new role"
    createRole(input: createRoleInput): createRolePayload
    createStock(input: createStockInput): createStockPayload
    "Create a new user"
    createUser(input: createUserInput): createUserPayload
    createVirtualStock(input: createVirtualStockInput): createVirtualStockPayload
    deleteBrand(input: deleteBrandInput): deleteBrandPayload
    deleteCart(input: deleteCartInput): deleteCartPayload
    deleteCategory(input: deleteCategoryInput): deleteCategoryPayload
    deleteConsignment(input: deleteConsignmentInput): deleteConsignmentPayload
    deleteContact: deleteContactPayload
    "Delete one file"
    deleteFile(input: deleteFileInput): deleteFilePayload
    deleteGroup(input: deleteGroupInput): deleteGroupPayload
    deleteOrder(input: deleteOrderInput): deleteOrderPayload
    deleteProduct(input: deleteProductInput): deleteProductPayload
    deleteProductFromCart(productId: ID!): Cart!
    "Delete an existing role"
    deleteRole(input: deleteRoleInput): deleteRolePayload
    deleteStock(input: deleteStockInput): deleteStockPayload
    "Delete an existing user"
    deleteUser(input: deleteUserInput): deleteUserPayload
    deleteVirtualStock(input: deleteVirtualStockInput): deleteVirtualStockPayload
    emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
    forgotPassword(email: String!): UserPermissionsPasswordPayload
    login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
    multipleUpload(field: String, files: [Upload]!, ref: String, refId: ID, source: String): [UploadFile]!
    register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
    requestQuote(id: ID!): String
    resetCart: Cart!
    resetPassword(code: String!, password: String!, passwordConfirmation: String!): UsersPermissionsLoginPayload
    updateBrand(input: updateBrandInput): updateBrandPayload
    updateCart(input: updateCartInput): updateCartPayload
    updateCategory(input: updateCategoryInput): updateCategoryPayload
    updateConsignment(input: updateConsignmentInput): updateConsignmentPayload
    updateContact(input: updateContactInput): updateContactPayload
    updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
    updateGroup(input: updateGroupInput): updateGroupPayload
    updateOrder(input: updateOrderInput): updateOrderPayload
    updateProduct(input: updateProductInput): updateProductPayload
    "Update an existing role"
    updateRole(input: updateRoleInput): updateRolePayload
    updateStock(input: updateStockInput): updateStockPayload
    "Update an existing user"
    updateUser(input: updateUserInput): updateUserPayload
    updateVirtualStock(input: updateVirtualStockInput): updateVirtualStockPayload
    upload(field: String, file: Upload!, info: FileInfoInput, ref: String, refId: ID, source: String): UploadFile!
}

type Order {
    _id: ID!
    createdAt: DateTime!
    deliveryInstruction: String
    id: ID!
    invoice: String
    poNumber: String
    requestedShippingDate: Date
    saleProductData: [ComponentSaleProductDataSaleProductData]
    status: ENUM_ORDER_STATUS
    updatedAt: DateTime!
    user: UsersPermissionsUser
}

type OrderAggregator {
    count: Int
    totalCount: Int
}

type OrderConnection {
    aggregate: OrderAggregator
    groupBy: OrderGroupBy
    values: [Order]
}

type OrderConnectionCreatedAt {
    connection: OrderConnection
    key: DateTime
}

type OrderConnectionDeliveryInstruction {
    connection: OrderConnection
    key: String
}

type OrderConnectionId {
    connection: OrderConnection
    key: ID
}

type OrderConnectionInvoice {
    connection: OrderConnection
    key: String
}

type OrderConnectionPoNumber {
    connection: OrderConnection
    key: String
}

type OrderConnectionRequestedShippingDate {
    connection: OrderConnection
    key: ID
}

type OrderConnectionStatus {
    connection: OrderConnection
    key: String
}

type OrderConnectionUpdatedAt {
    connection: OrderConnection
    key: DateTime
}

type OrderConnectionUser {
    connection: OrderConnection
    key: ID
}

type OrderConnection_id {
    connection: OrderConnection
    key: ID
}

type OrderGroupBy {
    _id: [OrderConnection_id]
    createdAt: [OrderConnectionCreatedAt]
    deliveryInstruction: [OrderConnectionDeliveryInstruction]
    id: [OrderConnectionId]
    invoice: [OrderConnectionInvoice]
    poNumber: [OrderConnectionPoNumber]
    requestedShippingDate: [OrderConnectionRequestedShippingDate]
    status: [OrderConnectionStatus]
    updatedAt: [OrderConnectionUpdatedAt]
    user: [OrderConnectionUser]
}

type Product {
    _id: ID!
    availableOnVirtualStock: [ComponentVirtualStockAvailableOnVirtualStock]
    brand: Brand
    code_1c: String
    code_1c_uom: String
    color: String
    consignments(limit: Int, sort: String, start: Int, where: JSON): [Consignment]
    createdAt: DateTime!
    deletedFromSearch: Boolean
    description_en: String
    description_ru: String
    expectedDeliveryDate: Date
    group: Group
    id: ID!
    link: String
    longRead_en: String
    longRead_ru: String
    mfg: String
    photo: UploadFile
    pn: String
    price_en: Float!
    price_ru: Float!
    sync1cDisplay: Boolean
    unitDimension: ENUM_PRODUCT_UNITDIMENSION
    uom: String
    updatedAt: DateTime!
}

type ProductAggregator {
    avg: ProductAggregatorAvg
    count: Int
    max: ProductAggregatorMax
    min: ProductAggregatorMin
    sum: ProductAggregatorSum
    totalCount: Int
}

type ProductAggregatorAvg {
    price_en: Float
    price_ru: Float
}

type ProductAggregatorMax {
    price_en: Float
    price_ru: Float
}

type ProductAggregatorMin {
    price_en: Float
    price_ru: Float
}

type ProductAggregatorSum {
    price_en: Float
    price_ru: Float
}

type ProductConnection {
    aggregate: ProductAggregator
    groupBy: ProductGroupBy
    values: [Product]
}

type ProductConnectionBrand {
    connection: ProductConnection
    key: ID
}

type ProductConnectionCode_1c {
    connection: ProductConnection
    key: String
}

type ProductConnectionCode_1c_uom {
    connection: ProductConnection
    key: String
}

type ProductConnectionColor {
    connection: ProductConnection
    key: String
}

type ProductConnectionCreatedAt {
    connection: ProductConnection
    key: DateTime
}

type ProductConnectionDeletedFromSearch {
    connection: ProductConnection
    key: Boolean
}

type ProductConnectionDescription_en {
    connection: ProductConnection
    key: String
}

type ProductConnectionDescription_ru {
    connection: ProductConnection
    key: String
}

type ProductConnectionExpectedDeliveryDate {
    connection: ProductConnection
    key: ID
}

type ProductConnectionGroup {
    connection: ProductConnection
    key: ID
}

type ProductConnectionId {
    connection: ProductConnection
    key: ID
}

type ProductConnectionLink {
    connection: ProductConnection
    key: String
}

type ProductConnectionLongRead_en {
    connection: ProductConnection
    key: String
}

type ProductConnectionLongRead_ru {
    connection: ProductConnection
    key: String
}

type ProductConnectionMfg {
    connection: ProductConnection
    key: String
}

type ProductConnectionPhoto {
    connection: ProductConnection
    key: ID
}

type ProductConnectionPn {
    connection: ProductConnection
    key: String
}

type ProductConnectionPrice_en {
    connection: ProductConnection
    key: Float
}

type ProductConnectionPrice_ru {
    connection: ProductConnection
    key: Float
}

type ProductConnectionSync1cDisplay {
    connection: ProductConnection
    key: Boolean
}

type ProductConnectionUnitDimension {
    connection: ProductConnection
    key: String
}

type ProductConnectionUom {
    connection: ProductConnection
    key: String
}

type ProductConnectionUpdatedAt {
    connection: ProductConnection
    key: DateTime
}

type ProductConnection_id {
    connection: ProductConnection
    key: ID
}

type ProductGroupBy {
    _id: [ProductConnection_id]
    brand: [ProductConnectionBrand]
    code_1c: [ProductConnectionCode_1c]
    code_1c_uom: [ProductConnectionCode_1c_uom]
    color: [ProductConnectionColor]
    createdAt: [ProductConnectionCreatedAt]
    deletedFromSearch: [ProductConnectionDeletedFromSearch]
    description_en: [ProductConnectionDescription_en]
    description_ru: [ProductConnectionDescription_ru]
    expectedDeliveryDate: [ProductConnectionExpectedDeliveryDate]
    group: [ProductConnectionGroup]
    id: [ProductConnectionId]
    link: [ProductConnectionLink]
    longRead_en: [ProductConnectionLongRead_en]
    longRead_ru: [ProductConnectionLongRead_ru]
    mfg: [ProductConnectionMfg]
    photo: [ProductConnectionPhoto]
    pn: [ProductConnectionPn]
    price_en: [ProductConnectionPrice_en]
    price_ru: [ProductConnectionPrice_ru]
    sync1cDisplay: [ProductConnectionSync1cDisplay]
    unitDimension: [ProductConnectionUnitDimension]
    uom: [ProductConnectionUom]
    updatedAt: [ProductConnectionUpdatedAt]
}

type Query {
    brand(id: ID!, publicationState: PublicationState): Brand
    brands(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Brand]
    brandsConnection(limit: Int, sort: String, start: Int, where: JSON): BrandConnection
    cart(id: ID!, publicationState: PublicationState): Cart
    carts(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Cart]
    cartsConnection(limit: Int, sort: String, start: Int, where: JSON): CartConnection
    categories(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Category]
    categoriesConnection(limit: Int, sort: String, start: Int, where: JSON): CategoryConnection
    category(id: ID!, publicationState: PublicationState): Category
    consignment(id: ID!, publicationState: PublicationState): Consignment
    consignments(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Consignment]
    consignmentsConnection(limit: Int, sort: String, start: Int, where: JSON): ConsignmentConnection
    contact(publicationState: PublicationState): Contacts
    countProductsInCart: Int
    files(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UploadFile]
    filesConnection(limit: Int, sort: String, start: Int, where: JSON): UploadFileConnection
    getCart: Cart!
    group(id: ID!, publicationState: PublicationState): Group
    groups(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Group]
    groupsConnection(limit: Int, sort: String, start: Int, where: JSON): GroupConnection
    me: UsersPermissionsMe
    order(id: ID!, publicationState: PublicationState): Order
    orders(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Order]
    ordersConnection(limit: Int, sort: String, start: Int, where: JSON): OrderConnection
    product(id: ID!, publicationState: PublicationState): Product
    products(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Product]
    productsConnection(limit: Int, sort: String, start: Int, where: JSON): ProductConnection
    role(id: ID!, publicationState: PublicationState): UsersPermissionsRole
    "Retrieve all the existing roles. You can't apply filters on this query."
    roles(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UsersPermissionsRole]
    rolesConnection(limit: Int, sort: String, start: Int, where: JSON): UsersPermissionsRoleConnection
    stock(id: ID!, publicationState: PublicationState): Stock
    stocks(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Stock]
    stocksConnection(limit: Int, sort: String, start: Int, where: JSON): StockConnection
    user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
    users(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
    usersConnection(limit: Int, sort: String, start: Int, where: JSON): UsersPermissionsUserConnection
    virtualStock(id: ID!, publicationState: PublicationState): VirtualStock
    virtualStocks(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [VirtualStock]
    virtualStocksConnection(limit: Int, sort: String, start: Int, where: JSON): VirtualStockConnection
}

type Stock {
    _id: ID!
    createdAt: DateTime!
    id: ID!
    name: String
    updatedAt: DateTime!
}

type StockAggregator {
    count: Int
    totalCount: Int
}

type StockConnection {
    aggregate: StockAggregator
    groupBy: StockGroupBy
    values: [Stock]
}

type StockConnectionCreatedAt {
    connection: StockConnection
    key: DateTime
}

type StockConnectionId {
    connection: StockConnection
    key: ID
}

type StockConnectionName {
    connection: StockConnection
    key: String
}

type StockConnectionUpdatedAt {
    connection: StockConnection
    key: DateTime
}

type StockConnection_id {
    connection: StockConnection
    key: ID
}

type StockGroupBy {
    _id: [StockConnection_id]
    createdAt: [StockConnectionCreatedAt]
    id: [StockConnectionId]
    name: [StockConnectionName]
    updatedAt: [StockConnectionUpdatedAt]
}

type UploadFile {
    _id: ID!
    alternativeText: String
    caption: String
    createdAt: DateTime!
    ext: String
    formats: JSON
    hash: String!
    height: Int
    id: ID!
    mime: String!
    name: String!
    previewUrl: String
    provider: String!
    provider_metadata: JSON
    related(limit: Int, sort: String, start: Int, where: JSON): [Morph]
    size: Float!
    updatedAt: DateTime!
    url: String!
    width: Int
}

type UploadFileAggregator {
    avg: UploadFileAggregatorAvg
    count: Int
    max: UploadFileAggregatorMax
    min: UploadFileAggregatorMin
    sum: UploadFileAggregatorSum
    totalCount: Int
}

type UploadFileAggregatorAvg {
    height: Float
    size: Float
    width: Float
}

type UploadFileAggregatorMax {
    height: Float
    size: Float
    width: Float
}

type UploadFileAggregatorMin {
    height: Float
    size: Float
    width: Float
}

type UploadFileAggregatorSum {
    height: Float
    size: Float
    width: Float
}

type UploadFileConnection {
    aggregate: UploadFileAggregator
    groupBy: UploadFileGroupBy
    values: [UploadFile]
}

type UploadFileConnectionAlternativeText {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionCaption {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionCreatedAt {
    connection: UploadFileConnection
    key: DateTime
}

type UploadFileConnectionExt {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionFormats {
    connection: UploadFileConnection
    key: JSON
}

type UploadFileConnectionHash {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionHeight {
    connection: UploadFileConnection
    key: Int
}

type UploadFileConnectionId {
    connection: UploadFileConnection
    key: ID
}

type UploadFileConnectionMime {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionName {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionPreviewUrl {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionProvider {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionProvider_metadata {
    connection: UploadFileConnection
    key: JSON
}

type UploadFileConnectionSize {
    connection: UploadFileConnection
    key: Float
}

type UploadFileConnectionUpdatedAt {
    connection: UploadFileConnection
    key: DateTime
}

type UploadFileConnectionUrl {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionWidth {
    connection: UploadFileConnection
    key: Int
}

type UploadFileConnection_id {
    connection: UploadFileConnection
    key: ID
}

type UploadFileGroupBy {
    _id: [UploadFileConnection_id]
    alternativeText: [UploadFileConnectionAlternativeText]
    caption: [UploadFileConnectionCaption]
    createdAt: [UploadFileConnectionCreatedAt]
    ext: [UploadFileConnectionExt]
    formats: [UploadFileConnectionFormats]
    hash: [UploadFileConnectionHash]
    height: [UploadFileConnectionHeight]
    id: [UploadFileConnectionId]
    mime: [UploadFileConnectionMime]
    name: [UploadFileConnectionName]
    previewUrl: [UploadFileConnectionPreviewUrl]
    provider: [UploadFileConnectionProvider]
    provider_metadata: [UploadFileConnectionProvider_metadata]
    size: [UploadFileConnectionSize]
    updatedAt: [UploadFileConnectionUpdatedAt]
    url: [UploadFileConnectionUrl]
    width: [UploadFileConnectionWidth]
}

type UserPermissionsPasswordPayload {
    ok: Boolean!
}

type UsersPermissionsLoginPayload {
    jwt: String
    user: UsersPermissionsMe!
}

type UsersPermissionsMe {
    blocked: Boolean
    cart: Cart
    confirmed: Boolean
    email: String!
    id: ID!
    role: UsersPermissionsMeRole
    user: UsersPermissionsUser
    username: String!
}

type UsersPermissionsMeRole {
    description: String
    id: ID!
    name: String!
    type: String
}

type UsersPermissionsPermission {
    _id: ID!
    action: String!
    controller: String!
    enabled: Boolean!
    id: ID!
    policy: String
    role: UsersPermissionsRole
    type: String!
}

type UsersPermissionsRole {
    _id: ID!
    description: String
    id: ID!
    name: String!
    permissions(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsPermission]
    type: String
    users(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleAggregator {
    count: Int
    totalCount: Int
}

type UsersPermissionsRoleConnection {
    aggregate: UsersPermissionsRoleAggregator
    groupBy: UsersPermissionsRoleGroupBy
    values: [UsersPermissionsRole]
}

type UsersPermissionsRoleConnectionDescription {
    connection: UsersPermissionsRoleConnection
    key: String
}

type UsersPermissionsRoleConnectionId {
    connection: UsersPermissionsRoleConnection
    key: ID
}

type UsersPermissionsRoleConnectionName {
    connection: UsersPermissionsRoleConnection
    key: String
}

type UsersPermissionsRoleConnectionType {
    connection: UsersPermissionsRoleConnection
    key: String
}

type UsersPermissionsRoleConnection_id {
    connection: UsersPermissionsRoleConnection
    key: ID
}

type UsersPermissionsRoleGroupBy {
    _id: [UsersPermissionsRoleConnection_id]
    description: [UsersPermissionsRoleConnectionDescription]
    id: [UsersPermissionsRoleConnectionId]
    name: [UsersPermissionsRoleConnectionName]
    type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsUser {
    _id: ID!
    blocked: Boolean
    cart: Cart
    confirmed: Boolean
    createdAt: DateTime!
    customerInfo: ComponentCustomerCustomer
    email: String!
    id: ID!
    orders(limit: Int, sort: String, start: Int, where: JSON): [Order]
    provider: String
    role: UsersPermissionsRole
    updatedAt: DateTime!
    username: String!
    verifiedByAdmin: Boolean
}

type UsersPermissionsUserAggregator {
    count: Int
    totalCount: Int
}

type UsersPermissionsUserConnection {
    aggregate: UsersPermissionsUserAggregator
    groupBy: UsersPermissionsUserGroupBy
    values: [UsersPermissionsUser]
}

type UsersPermissionsUserConnectionBlocked {
    connection: UsersPermissionsUserConnection
    key: Boolean
}

type UsersPermissionsUserConnectionCart {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionConfirmed {
    connection: UsersPermissionsUserConnection
    key: Boolean
}

type UsersPermissionsUserConnectionCreatedAt {
    connection: UsersPermissionsUserConnection
    key: DateTime
}

type UsersPermissionsUserConnectionCustomerInfo {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionEmail {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionId {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionProvider {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionRole {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionUpdatedAt {
    connection: UsersPermissionsUserConnection
    key: DateTime
}

type UsersPermissionsUserConnectionUsername {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionVerifiedByAdmin {
    connection: UsersPermissionsUserConnection
    key: Boolean
}

type UsersPermissionsUserConnection_id {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserGroupBy {
    _id: [UsersPermissionsUserConnection_id]
    blocked: [UsersPermissionsUserConnectionBlocked]
    cart: [UsersPermissionsUserConnectionCart]
    confirmed: [UsersPermissionsUserConnectionConfirmed]
    createdAt: [UsersPermissionsUserConnectionCreatedAt]
    customerInfo: [UsersPermissionsUserConnectionCustomerInfo]
    email: [UsersPermissionsUserConnectionEmail]
    id: [UsersPermissionsUserConnectionId]
    provider: [UsersPermissionsUserConnectionProvider]
    role: [UsersPermissionsUserConnectionRole]
    updatedAt: [UsersPermissionsUserConnectionUpdatedAt]
    username: [UsersPermissionsUserConnectionUsername]
    verifiedByAdmin: [UsersPermissionsUserConnectionVerifiedByAdmin]
}

type VirtualStock {
    _id: ID!
    address: String
    createdAt: DateTime!
    id: ID!
    name: String
    updatedAt: DateTime!
}

type VirtualStockAggregator {
    count: Int
    totalCount: Int
}

type VirtualStockConnection {
    aggregate: VirtualStockAggregator
    groupBy: VirtualStockGroupBy
    values: [VirtualStock]
}

type VirtualStockConnectionAddress {
    connection: VirtualStockConnection
    key: String
}

type VirtualStockConnectionCreatedAt {
    connection: VirtualStockConnection
    key: DateTime
}

type VirtualStockConnectionId {
    connection: VirtualStockConnection
    key: ID
}

type VirtualStockConnectionName {
    connection: VirtualStockConnection
    key: String
}

type VirtualStockConnectionUpdatedAt {
    connection: VirtualStockConnection
    key: DateTime
}

type VirtualStockConnection_id {
    connection: VirtualStockConnection
    key: ID
}

type VirtualStockGroupBy {
    _id: [VirtualStockConnection_id]
    address: [VirtualStockConnectionAddress]
    createdAt: [VirtualStockConnectionCreatedAt]
    id: [VirtualStockConnectionId]
    name: [VirtualStockConnectionName]
    updatedAt: [VirtualStockConnectionUpdatedAt]
}

type createBrandPayload {
    brand: Brand
}

type createCartPayload {
    cart: Cart
}

type createCategoryPayload {
    category: Category
}

type createConsignmentPayload {
    consignment: Consignment
}

type createGroupPayload {
    group: Group
}

type createOrderPayload {
    order: Order
}

type createProductPayload {
    product: Product
}

type createRolePayload {
    role: UsersPermissionsRole
}

type createStockPayload {
    stock: Stock
}

type createUserPayload {
    user: UsersPermissionsUser
}

type createVirtualStockPayload {
    virtualStock: VirtualStock
}

type deleteBrandPayload {
    brand: Brand
}

type deleteCartPayload {
    cart: Cart
}

type deleteCategoryPayload {
    category: Category
}

type deleteConsignmentPayload {
    consignment: Consignment
}

type deleteContactPayload {
    contact: Contacts
}

type deleteFilePayload {
    file: UploadFile
}

type deleteGroupPayload {
    group: Group
}

type deleteOrderPayload {
    order: Order
}

type deleteProductPayload {
    product: Product
}

type deleteRolePayload {
    role: UsersPermissionsRole
}

type deleteStockPayload {
    stock: Stock
}

type deleteUserPayload {
    user: UsersPermissionsUser
}

type deleteVirtualStockPayload {
    virtualStock: VirtualStock
}

type updateBrandPayload {
    brand: Brand
}

type updateCartPayload {
    cart: Cart
}

type updateCategoryPayload {
    category: Category
}

type updateConsignmentPayload {
    consignment: Consignment
}

type updateContactPayload {
    contact: Contacts
}

type updateGroupPayload {
    group: Group
}

type updateOrderPayload {
    order: Order
}

type updateProductPayload {
    product: Product
}

type updateRolePayload {
    role: UsersPermissionsRole
}

type updateStockPayload {
    stock: Stock
}

type updateUserPayload {
    user: UsersPermissionsUser
}

type updateVirtualStockPayload {
    virtualStock: VirtualStock
}

enum ENUM_ORDER_STATUS {
    closed
    inProgress
    open
    paid
}

enum ENUM_PRODUCT_UNITDIMENSION {
    unit
}

enum PublicationState {
    LIVE
    PREVIEW
}

input BrandInput {
    created_by: ID
    name: String
    photo: ID
    products: [ID]
    updated_by: ID
}

input CartInput {
    cartItems: [ComponentCartCartItemInput]
    created_by: ID
    updated_by: ID
    user: ID
}

input CategoryInput {
    created_by: ID
    groups: [ID]
    name: String!
    updated_by: ID
}

input ComponentCartCartItemInput {
    count: Int
    product: ID
}

input ComponentCustomerCustomerInput {
    company: String
    phone: String
}

input ComponentPlacementPlacementInput {
    balance: Int
    stock: ID
}

input ComponentSaleProductDataSaleProductDatumInput {
    count: Int
    product: ID
    sellingPrice: Float
}

input ComponentVirtualStockAvailableOnVirtualStockInput {
    virtual_stocks: [ID]
}

input ConsignmentInput {
    code_1c: String
    created_by: ID
    name: String
    placements: [ComponentPlacementPlacementInput]
    product: ID
    productionDate: Date
    published_at: DateTime
    updated_by: ID
    validUntil: Date
}

input ContactInput {
    address: String
    created_by: ID
    email: String
    phone: String
    published_at: DateTime
    updated_by: ID
}

input FileInfoInput {
    alternativeText: String
    caption: String
    name: String
}

input FileInput {
    alternativeText: String
    caption: String
    created_by: ID
    ext: String
    formats: JSON
    hash: String!
    height: Int
    mime: String!
    name: String!
    previewUrl: String
    provider: String!
    provider_metadata: JSON
    related: [ID]
    size: Float!
    updated_by: ID
    url: String!
    width: Int
}

input GroupInput {
    category: ID
    created_by: ID
    name: String
    products: [ID]
    updated_by: ID
}

input InputID {
    id: ID!
}

input OrderInput {
    created_by: ID
    deliveryInstruction: String
    invoice: String
    poNumber: String
    requestedShippingDate: Date
    saleProductData: [ComponentSaleProductDataSaleProductDatumInput]
    status: ENUM_ORDER_STATUS
    updated_by: ID
    user: ID
}

input ProductInput {
    availableOnVirtualStock: [ComponentVirtualStockAvailableOnVirtualStockInput]
    brand: ID
    code_1c: String
    code_1c_uom: String
    color: String
    consignments: [ID]
    created_by: ID
    deletedFromSearch: Boolean
    description_en: String
    description_ru: String
    expectedDeliveryDate: Date
    group: ID
    link: String
    longRead_en: String
    longRead_ru: String
    mfg: String
    photo: ID
    pn: String
    price_en: Float
    price_ru: Float
    sync1cDisplay: Boolean
    unitDimension: ENUM_PRODUCT_UNITDIMENSION
    uom: String
    updated_by: ID
}

input RoleInput {
    created_by: ID
    description: String
    name: String!
    permissions: [ID]
    type: String
    updated_by: ID
    users: [ID]
}

input StockInput {
    created_by: ID
    name: String
    updated_by: ID
}

input UserInput {
    blocked: Boolean
    cart: ID
    confirmationToken: String
    confirmed: Boolean
    created_by: ID
    customerInfo: ComponentCustomerCustomerInput
    email: String!
    orders: [ID]
    password: String
    provider: String
    resetPasswordToken: String
    role: ID
    updated_by: ID
    username: String!
    verifiedByAdmin: Boolean
}

input UsersPermissionsLoginInput {
    identifier: String!
    password: String!
    provider: String = "local"
}

input UsersPermissionsRegisterInput {
    email: String!
    password: String!
    username: String!
}

input VirtualStockInput {
    address: String
    created_by: ID
    name: String
    updated_by: ID
}

input createBrandInput {
    data: BrandInput
}

input createCartInput {
    data: CartInput
}

input createCategoryInput {
    data: CategoryInput
}

input createConsignmentInput {
    data: ConsignmentInput
}

input createGroupInput {
    data: GroupInput
}

input createOrderInput {
    data: OrderInput
}

input createProductInput {
    data: ProductInput
}

input createRoleInput {
    data: RoleInput
}

input createStockInput {
    data: StockInput
}

input createUserInput {
    data: UserInput
}

input createVirtualStockInput {
    data: VirtualStockInput
}

input deleteBrandInput {
    where: InputID
}

input deleteCartInput {
    where: InputID
}

input deleteCategoryInput {
    where: InputID
}

input deleteConsignmentInput {
    where: InputID
}

input deleteFileInput {
    where: InputID
}

input deleteGroupInput {
    where: InputID
}

input deleteOrderInput {
    where: InputID
}

input deleteProductInput {
    where: InputID
}

input deleteRoleInput {
    where: InputID
}

input deleteStockInput {
    where: InputID
}

input deleteUserInput {
    where: InputID
}

input deleteVirtualStockInput {
    where: InputID
}

input editBrandInput {
    created_by: ID
    name: String
    photo: ID
    products: [ID]
    updated_by: ID
}

input editCartInput {
    cartItems: [editComponentCartCartItemInput]
    created_by: ID
    updated_by: ID
    user: ID
}

input editCategoryInput {
    created_by: ID
    groups: [ID]
    name: String
    updated_by: ID
}

input editComponentCartCartItemInput {
    count: Int
    id: ID
    product: ID
}

input editComponentCustomerCustomerInput {
    company: String
    id: ID
    phone: String
}

input editComponentPlacementPlacementInput {
    balance: Int
    id: ID
    stock: ID
}

input editComponentSaleProductDataSaleProductDatumInput {
    count: Int
    id: ID
    product: ID
    sellingPrice: Float
}

input editComponentVirtualStockAvailableOnVirtualStockInput {
    id: ID
    virtual_stocks: [ID]
}

input editConsignmentInput {
    code_1c: String
    created_by: ID
    name: String
    placements: [editComponentPlacementPlacementInput]
    product: ID
    productionDate: Date
    published_at: DateTime
    updated_by: ID
    validUntil: Date
}

input editContactInput {
    address: String
    created_by: ID
    email: String
    phone: String
    published_at: DateTime
    updated_by: ID
}

input editFileInput {
    alternativeText: String
    caption: String
    created_by: ID
    ext: String
    formats: JSON
    hash: String
    height: Int
    mime: String
    name: String
    previewUrl: String
    provider: String
    provider_metadata: JSON
    related: [ID]
    size: Float
    updated_by: ID
    url: String
    width: Int
}

input editGroupInput {
    category: ID
    created_by: ID
    name: String
    products: [ID]
    updated_by: ID
}

input editOrderInput {
    created_by: ID
    deliveryInstruction: String
    invoice: String
    poNumber: String
    requestedShippingDate: Date
    saleProductData: [editComponentSaleProductDataSaleProductDatumInput]
    status: ENUM_ORDER_STATUS
    updated_by: ID
    user: ID
}

input editProductInput {
    availableOnVirtualStock: [editComponentVirtualStockAvailableOnVirtualStockInput]
    brand: ID
    code_1c: String
    code_1c_uom: String
    color: String
    consignments: [ID]
    created_by: ID
    deletedFromSearch: Boolean
    description_en: String
    description_ru: String
    expectedDeliveryDate: Date
    group: ID
    link: String
    longRead_en: String
    longRead_ru: String
    mfg: String
    photo: ID
    pn: String
    price_en: Float
    price_ru: Float
    sync1cDisplay: Boolean
    unitDimension: ENUM_PRODUCT_UNITDIMENSION
    uom: String
    updated_by: ID
}

input editRoleInput {
    created_by: ID
    description: String
    name: String
    permissions: [ID]
    type: String
    updated_by: ID
    users: [ID]
}

input editStockInput {
    created_by: ID
    name: String
    updated_by: ID
}

input editUserInput {
    blocked: Boolean
    cart: ID
    confirmationToken: String
    confirmed: Boolean
    created_by: ID
    customerInfo: editComponentCustomerCustomerInput
    email: String
    orders: [ID]
    password: String
    provider: String
    resetPasswordToken: String
    role: ID
    updated_by: ID
    username: String
    verifiedByAdmin: Boolean
}

input editVirtualStockInput {
    address: String
    created_by: ID
    name: String
    updated_by: ID
}

input updateBrandInput {
    data: editBrandInput
    where: InputID
}

input updateCartInput {
    data: editCartInput
    where: InputID
}

input updateCategoryInput {
    data: editCategoryInput
    where: InputID
}

input updateConsignmentInput {
    data: editConsignmentInput
    where: InputID
}

input updateContactInput {
    data: editContactInput
}

input updateGroupInput {
    data: editGroupInput
    where: InputID
}

input updateOrderInput {
    data: editOrderInput
    where: InputID
}

input updateProductInput {
    data: editProductInput
    where: InputID
}

input updateRoleInput {
    data: editRoleInput
    where: InputID
}

input updateStockInput {
    data: editStockInput
    where: InputID
}

input updateUserInput {
    data: editUserInput
    where: InputID
}

input updateVirtualStockInput {
    data: editVirtualStockInput
    where: InputID
}


"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime

"A time string with format: HH:mm:ss.SSS"
scalar Time

"A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar Date

"The `Long` scalar type represents 52-bit integers"
scalar Long

"The `Upload` scalar type represents a file upload."
scalar Upload