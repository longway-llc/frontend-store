"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

input FileInfoInput {
  name: String
  alternativeText: String
  caption: String
}

type UsersPermissionsMe {
  id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
  user: UsersPermissionsUser
  cart: Cart
}

type UsersPermissionsMeRole {
  id: ID!
  name: String!
  description: String
  type: String
}

input UsersPermissionsRegisterInput {
  username: String!
  email: String!
  password: String!
}

input UsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String = "local"
}

type UsersPermissionsLoginPayload {
  jwt: String
  user: UsersPermissionsMe!
}

type UserPermissionsPasswordPayload {
  ok: Boolean!
}

type Brand {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  photo: UploadFile
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
}

type BrandConnection {
  values: [Brand]
  groupBy: BrandGroupBy
  aggregate: BrandAggregator
}

type BrandAggregator {
  count: Int
  totalCount: Int
}

type BrandGroupBy {
  id: [BrandConnectionId]
  _id: [BrandConnection_id]
  createdAt: [BrandConnectionCreatedAt]
  updatedAt: [BrandConnectionUpdatedAt]
  name: [BrandConnectionName]
  photo: [BrandConnectionPhoto]
}

type BrandConnectionId {
  key: ID
  connection: BrandConnection
}

type BrandConnection_id {
  key: ID
  connection: BrandConnection
}

type BrandConnectionCreatedAt {
  key: DateTime
  connection: BrandConnection
}

type BrandConnectionUpdatedAt {
  key: DateTime
  connection: BrandConnection
}

type BrandConnectionName {
  key: String
  connection: BrandConnection
}

type BrandConnectionPhoto {
  key: ID
  connection: BrandConnection
}

input BrandInput {
  name: String
  products: [ID]
  photo: ID
  created_by: ID
  updated_by: ID
}

input editBrandInput {
  name: String
  products: [ID]
  photo: ID
  created_by: ID
  updated_by: ID
}

input createBrandInput {
  data: BrandInput
}

type createBrandPayload {
  brand: Brand
}

input updateBrandInput {
  where: InputID
  data: editBrandInput
}

type updateBrandPayload {
  brand: Brand
}

input deleteBrandInput {
  where: InputID
}

type deleteBrandPayload {
  brand: Brand
}

type Cart {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  cartItems: [ComponentCartCartItem]
  user: UsersPermissionsUser
}

type CartConnection {
  values: [Cart]
  groupBy: CartGroupBy
  aggregate: CartAggregator
}

type CartAggregator {
  count: Int
  totalCount: Int
}

type CartGroupBy {
  id: [CartConnectionId]
  _id: [CartConnection_id]
  createdAt: [CartConnectionCreatedAt]
  updatedAt: [CartConnectionUpdatedAt]
  user: [CartConnectionUser]
}

type CartConnectionId {
  key: ID
  connection: CartConnection
}

type CartConnection_id {
  key: ID
  connection: CartConnection
}

type CartConnectionCreatedAt {
  key: DateTime
  connection: CartConnection
}

type CartConnectionUpdatedAt {
  key: DateTime
  connection: CartConnection
}

type CartConnectionUser {
  key: ID
  connection: CartConnection
}

input CartInput {
  cartItems: [ComponentCartCartItemInput]
  user: ID
  created_by: ID
  updated_by: ID
}

input editCartInput {
  cartItems: [editComponentCartCartItemInput]
  user: ID
  created_by: ID
  updated_by: ID
}

input createCartInput {
  data: CartInput
}

type createCartPayload {
  cart: Cart
}

input updateCartInput {
  where: InputID
  data: editCartInput
}

type updateCartPayload {
  cart: Cart
}

input deleteCartInput {
  where: InputID
}

type deleteCartPayload {
  cart: Cart
}

type Category {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  groups(sort: String, limit: Int, start: Int, where: JSON): [Group]
}

type CategoryConnection {
  values: [Category]
  groupBy: CategoryGroupBy
  aggregate: CategoryAggregator
}

type CategoryAggregator {
  count: Int
  totalCount: Int
}

type CategoryGroupBy {
  id: [CategoryConnectionId]
  _id: [CategoryConnection_id]
  createdAt: [CategoryConnectionCreatedAt]
  updatedAt: [CategoryConnectionUpdatedAt]
  name: [CategoryConnectionName]
}

type CategoryConnectionId {
  key: ID
  connection: CategoryConnection
}

type CategoryConnection_id {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionCreatedAt {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionUpdatedAt {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionName {
  key: String
  connection: CategoryConnection
}

input CategoryInput {
  name: String!
  groups: [ID]
  created_by: ID
  updated_by: ID
}

input editCategoryInput {
  name: String
  groups: [ID]
  created_by: ID
  updated_by: ID
}

input createCategoryInput {
  data: CategoryInput
}

type createCategoryPayload {
  category: Category
}

input updateCategoryInput {
  where: InputID
  data: editCategoryInput
}

type updateCategoryPayload {
  category: Category
}

input deleteCategoryInput {
  where: InputID
}

type deleteCategoryPayload {
  category: Category
}

type Consignment {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  productionDate: Date
  validUntil: Date
  code_1c: String
  product: Product
  placements: [ComponentPlacementPlacement]
  published_at: DateTime
}

type ConsignmentConnection {
  values: [Consignment]
  groupBy: ConsignmentGroupBy
  aggregate: ConsignmentAggregator
}

type ConsignmentAggregator {
  count: Int
  totalCount: Int
}

type ConsignmentGroupBy {
  id: [ConsignmentConnectionId]
  _id: [ConsignmentConnection_id]
  createdAt: [ConsignmentConnectionCreatedAt]
  updatedAt: [ConsignmentConnectionUpdatedAt]
  name: [ConsignmentConnectionName]
  productionDate: [ConsignmentConnectionProductionDate]
  validUntil: [ConsignmentConnectionValidUntil]
  code_1c: [ConsignmentConnectionCode_1c]
  product: [ConsignmentConnectionProduct]
  published_at: [ConsignmentConnectionPublished_at]
}

type ConsignmentConnectionId {
  key: ID
  connection: ConsignmentConnection
}

type ConsignmentConnection_id {
  key: ID
  connection: ConsignmentConnection
}

type ConsignmentConnectionCreatedAt {
  key: DateTime
  connection: ConsignmentConnection
}

type ConsignmentConnectionUpdatedAt {
  key: DateTime
  connection: ConsignmentConnection
}

type ConsignmentConnectionName {
  key: String
  connection: ConsignmentConnection
}

type ConsignmentConnectionProductionDate {
  key: ID
  connection: ConsignmentConnection
}

type ConsignmentConnectionValidUntil {
  key: ID
  connection: ConsignmentConnection
}

type ConsignmentConnectionCode_1c {
  key: String
  connection: ConsignmentConnection
}

type ConsignmentConnectionProduct {
  key: ID
  connection: ConsignmentConnection
}

type ConsignmentConnectionPublished_at {
  key: DateTime
  connection: ConsignmentConnection
}

input ConsignmentInput {
  name: String
  productionDate: Date
  validUntil: Date
  code_1c: String
  product: ID
  placements: [ComponentPlacementPlacementInput]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editConsignmentInput {
  name: String
  productionDate: Date
  validUntil: Date
  code_1c: String
  product: ID
  placements: [editComponentPlacementPlacementInput]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createConsignmentInput {
  data: ConsignmentInput
}

type createConsignmentPayload {
  consignment: Consignment
}

input updateConsignmentInput {
  where: InputID
  data: editConsignmentInput
}

type updateConsignmentPayload {
  consignment: Consignment
}

input deleteConsignmentInput {
  where: InputID
}

type deleteConsignmentPayload {
  consignment: Consignment
}

type Contacts {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String
  phone: String
  address: String
  published_at: DateTime
}

input ContactInput {
  email: String
  phone: String
  address: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editContactInput {
  email: String
  phone: String
  address: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input updateContactInput {
  data: editContactInput
}

type updateContactPayload {
  contact: Contacts
}

type deleteContactPayload {
  contact: Contacts
}

type Group {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  category: Category
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
}

type GroupConnection {
  values: [Group]
  groupBy: GroupGroupBy
  aggregate: GroupAggregator
}

type GroupAggregator {
  count: Int
  totalCount: Int
}

type GroupGroupBy {
  id: [GroupConnectionId]
  _id: [GroupConnection_id]
  createdAt: [GroupConnectionCreatedAt]
  updatedAt: [GroupConnectionUpdatedAt]
  name: [GroupConnectionName]
  category: [GroupConnectionCategory]
}

type GroupConnectionId {
  key: ID
  connection: GroupConnection
}

type GroupConnection_id {
  key: ID
  connection: GroupConnection
}

type GroupConnectionCreatedAt {
  key: DateTime
  connection: GroupConnection
}

type GroupConnectionUpdatedAt {
  key: DateTime
  connection: GroupConnection
}

type GroupConnectionName {
  key: String
  connection: GroupConnection
}

type GroupConnectionCategory {
  key: ID
  connection: GroupConnection
}

input GroupInput {
  name: String
  products: [ID]
  category: ID
  created_by: ID
  updated_by: ID
}

input editGroupInput {
  name: String
  products: [ID]
  category: ID
  created_by: ID
  updated_by: ID
}

input createGroupInput {
  data: GroupInput
}

type createGroupPayload {
  group: Group
}

input updateGroupInput {
  where: InputID
  data: editGroupInput
}

type updateGroupPayload {
  group: Group
}

input deleteGroupInput {
  where: InputID
}

type deleteGroupPayload {
  group: Group
}

enum ENUM_ORDER_STATUS {
  open
  inProgress
  paid
  closed
}

type Order {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: ENUM_ORDER_STATUS
  saleProductData: [ComponentSaleProductDataSaleProductData]
  user: UsersPermissionsUser
  invoice: String
  requestedShippingDate: Date
  deliveryInstruction: String
  poNumber: String
}

type OrderConnection {
  values: [Order]
  groupBy: OrderGroupBy
  aggregate: OrderAggregator
}

type OrderAggregator {
  count: Int
  totalCount: Int
}

type OrderGroupBy {
  id: [OrderConnectionId]
  _id: [OrderConnection_id]
  createdAt: [OrderConnectionCreatedAt]
  updatedAt: [OrderConnectionUpdatedAt]
  status: [OrderConnectionStatus]
  user: [OrderConnectionUser]
  invoice: [OrderConnectionInvoice]
  requestedShippingDate: [OrderConnectionRequestedShippingDate]
  deliveryInstruction: [OrderConnectionDeliveryInstruction]
  poNumber: [OrderConnectionPoNumber]
}

type OrderConnectionId {
  key: ID
  connection: OrderConnection
}

type OrderConnection_id {
  key: ID
  connection: OrderConnection
}

type OrderConnectionCreatedAt {
  key: DateTime
  connection: OrderConnection
}

type OrderConnectionUpdatedAt {
  key: DateTime
  connection: OrderConnection
}

type OrderConnectionStatus {
  key: String
  connection: OrderConnection
}

type OrderConnectionUser {
  key: ID
  connection: OrderConnection
}

type OrderConnectionInvoice {
  key: String
  connection: OrderConnection
}

type OrderConnectionRequestedShippingDate {
  key: ID
  connection: OrderConnection
}

type OrderConnectionDeliveryInstruction {
  key: String
  connection: OrderConnection
}

type OrderConnectionPoNumber {
  key: String
  connection: OrderConnection
}

input OrderInput {
  status: ENUM_ORDER_STATUS
  saleProductData: [ComponentSaleProductDataSaleProductDatumInput]
  user: ID
  invoice: String
  requestedShippingDate: Date
  deliveryInstruction: String
  poNumber: String
  created_by: ID
  updated_by: ID
}

input editOrderInput {
  status: ENUM_ORDER_STATUS
  saleProductData: [editComponentSaleProductDataSaleProductDatumInput]
  user: ID
  invoice: String
  requestedShippingDate: Date
  deliveryInstruction: String
  poNumber: String
  created_by: ID
  updated_by: ID
}

input createOrderInput {
  data: OrderInput
}

type createOrderPayload {
  order: Order
}

input updateOrderInput {
  where: InputID
  data: editOrderInput
}

type updateOrderPayload {
  order: Order
}

input deleteOrderInput {
  where: InputID
}

type deleteOrderPayload {
  order: Order
}

enum ENUM_PRODUCT_UNITDIMENSION {
  unit
}

type Product {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  pn: String
  description_ru: String
  longRead_ru: String
  uom: String
  code_1c_uom: String
  color: String
  mfg: String
  price_ru: Float!
  price_en: Float!
  photo: UploadFile
  code_1c: String
  description_en: String
  longRead_en: String
  group: Group
  link: String
  unitDimension: ENUM_PRODUCT_UNITDIMENSION
  brand: Brand
  sync1cDisplay: Boolean
  deletedFromSearch: Boolean
  expectedDeliveryDate: Date
  consignments(sort: String, limit: Int, start: Int, where: JSON): [Consignment]
}

type ProductConnection {
  values: [Product]
  groupBy: ProductGroupBy
  aggregate: ProductAggregator
}

type ProductAggregator {
  count: Int
  totalCount: Int
  sum: ProductAggregatorSum
  avg: ProductAggregatorAvg
  min: ProductAggregatorMin
  max: ProductAggregatorMax
}

type ProductAggregatorSum {
  price_ru: Float
  price_en: Float
}

type ProductAggregatorAvg {
  price_ru: Float
  price_en: Float
}

type ProductAggregatorMin {
  price_ru: Float
  price_en: Float
}

type ProductAggregatorMax {
  price_ru: Float
  price_en: Float
}

type ProductGroupBy {
  id: [ProductConnectionId]
  _id: [ProductConnection_id]
  createdAt: [ProductConnectionCreatedAt]
  updatedAt: [ProductConnectionUpdatedAt]
  pn: [ProductConnectionPn]
  description_ru: [ProductConnectionDescription_ru]
  longRead_ru: [ProductConnectionLongRead_ru]
  uom: [ProductConnectionUom]
  code_1c_uom: [ProductConnectionCode_1c_uom]
  color: [ProductConnectionColor]
  mfg: [ProductConnectionMfg]
  price_ru: [ProductConnectionPrice_ru]
  price_en: [ProductConnectionPrice_en]
  photo: [ProductConnectionPhoto]
  code_1c: [ProductConnectionCode_1c]
  description_en: [ProductConnectionDescription_en]
  longRead_en: [ProductConnectionLongRead_en]
  group: [ProductConnectionGroup]
  link: [ProductConnectionLink]
  unitDimension: [ProductConnectionUnitDimension]
  brand: [ProductConnectionBrand]
  sync1cDisplay: [ProductConnectionSync1cDisplay]
  deletedFromSearch: [ProductConnectionDeletedFromSearch]
  expectedDeliveryDate: [ProductConnectionExpectedDeliveryDate]
}

type ProductConnectionId {
  key: ID
  connection: ProductConnection
}

type ProductConnection_id {
  key: ID
  connection: ProductConnection
}

type ProductConnectionCreatedAt {
  key: DateTime
  connection: ProductConnection
}

type ProductConnectionUpdatedAt {
  key: DateTime
  connection: ProductConnection
}

type ProductConnectionPn {
  key: String
  connection: ProductConnection
}

type ProductConnectionDescription_ru {
  key: String
  connection: ProductConnection
}

type ProductConnectionLongRead_ru {
  key: String
  connection: ProductConnection
}

type ProductConnectionUom {
  key: String
  connection: ProductConnection
}

type ProductConnectionCode_1c_uom {
  key: String
  connection: ProductConnection
}

type ProductConnectionColor {
  key: String
  connection: ProductConnection
}

type ProductConnectionMfg {
  key: String
  connection: ProductConnection
}

type ProductConnectionPrice_ru {
  key: Float
  connection: ProductConnection
}

type ProductConnectionPrice_en {
  key: Float
  connection: ProductConnection
}

type ProductConnectionPhoto {
  key: ID
  connection: ProductConnection
}

type ProductConnectionCode_1c {
  key: String
  connection: ProductConnection
}

type ProductConnectionDescription_en {
  key: String
  connection: ProductConnection
}

type ProductConnectionLongRead_en {
  key: String
  connection: ProductConnection
}

type ProductConnectionGroup {
  key: ID
  connection: ProductConnection
}

type ProductConnectionLink {
  key: String
  connection: ProductConnection
}

type ProductConnectionUnitDimension {
  key: String
  connection: ProductConnection
}

type ProductConnectionBrand {
  key: ID
  connection: ProductConnection
}

type ProductConnectionSync1cDisplay {
  key: Boolean
  connection: ProductConnection
}

type ProductConnectionDeletedFromSearch {
  key: Boolean
  connection: ProductConnection
}

type ProductConnectionExpectedDeliveryDate {
  key: ID
  connection: ProductConnection
}

input ProductInput {
  pn: String
  description_ru: String
  longRead_ru: String
  uom: String
  code_1c_uom: String
  color: String
  mfg: String
  price_ru: Float
  price_en: Float
  photo: ID
  code_1c: String
  description_en: String
  longRead_en: String
  group: ID
  consignments: [ID]
  link: String
  unitDimension: ENUM_PRODUCT_UNITDIMENSION
  brand: ID
  sync1cDisplay: Boolean
  deletedFromSearch: Boolean
  expectedDeliveryDate: Date
  created_by: ID
  updated_by: ID
}

input editProductInput {
  pn: String
  description_ru: String
  longRead_ru: String
  uom: String
  code_1c_uom: String
  color: String
  mfg: String
  price_ru: Float
  price_en: Float
  photo: ID
  code_1c: String
  description_en: String
  longRead_en: String
  group: ID
  consignments: [ID]
  link: String
  unitDimension: ENUM_PRODUCT_UNITDIMENSION
  brand: ID
  sync1cDisplay: Boolean
  deletedFromSearch: Boolean
  expectedDeliveryDate: Date
  created_by: ID
  updated_by: ID
}

input createProductInput {
  data: ProductInput
}

type createProductPayload {
  product: Product
}

input updateProductInput {
  where: InputID
  data: editProductInput
}

type updateProductPayload {
  product: Product
}

input deleteProductInput {
  where: InputID
}

type deleteProductPayload {
  product: Product
}

type Stock {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
}

type StockConnection {
  values: [Stock]
  groupBy: StockGroupBy
  aggregate: StockAggregator
}

type StockAggregator {
  count: Int
  totalCount: Int
}

type StockGroupBy {
  id: [StockConnectionId]
  _id: [StockConnection_id]
  createdAt: [StockConnectionCreatedAt]
  updatedAt: [StockConnectionUpdatedAt]
  name: [StockConnectionName]
}

type StockConnectionId {
  key: ID
  connection: StockConnection
}

type StockConnection_id {
  key: ID
  connection: StockConnection
}

type StockConnectionCreatedAt {
  key: DateTime
  connection: StockConnection
}

type StockConnectionUpdatedAt {
  key: DateTime
  connection: StockConnection
}

type StockConnectionName {
  key: String
  connection: StockConnection
}

input StockInput {
  name: String
  created_by: ID
  updated_by: ID
}

input editStockInput {
  name: String
  created_by: ID
  updated_by: ID
}

input createStockInput {
  data: StockInput
}

type createStockPayload {
  stock: Stock
}

input updateStockInput {
  where: InputID
  data: editStockInput
}

type updateStockPayload {
  stock: Stock
}

input deleteStockInput {
  where: InputID
}

type deleteStockPayload {
  stock: Stock
}

type UploadFile {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph]
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileAggregator {
  count: Int
  totalCount: Int
  sum: UploadFileAggregatorSum
  avg: UploadFileAggregatorAvg
  min: UploadFileAggregatorMin
  max: UploadFileAggregatorMax
}

type UploadFileAggregatorSum {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorAvg {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMin {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMax {
  width: Float
  height: Float
  size: Float
}

type UploadFileGroupBy {
  id: [UploadFileConnectionId]
  _id: [UploadFileConnection_id]
  createdAt: [UploadFileConnectionCreatedAt]
  updatedAt: [UploadFileConnectionUpdatedAt]
  name: [UploadFileConnectionName]
  alternativeText: [UploadFileConnectionAlternativeText]
  caption: [UploadFileConnectionCaption]
  width: [UploadFileConnectionWidth]
  height: [UploadFileConnectionHeight]
  formats: [UploadFileConnectionFormats]
  hash: [UploadFileConnectionHash]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  previewUrl: [UploadFileConnectionPreviewUrl]
  provider: [UploadFileConnectionProvider]
  provider_metadata: [UploadFileConnectionProvider_metadata]
}

type UploadFileConnectionId {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnection_id {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreatedAt {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUpdatedAt {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionAlternativeText {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionCaption {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionWidth {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionHeight {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionFormats {
  key: JSON
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: Float
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPreviewUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider_metadata {
  key: JSON
  connection: UploadFileConnection
}

input FileInput {
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input editFileInput {
  name: String
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String
  ext: String
  mime: String
  size: Float
  url: String
  previewUrl: String
  provider: String
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input deleteFileInput {
  where: InputID
}

type deleteFilePayload {
  file: UploadFile
}

type UsersPermissionsPermission {
  id: ID!
  _id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  id: ID!
  _id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission]
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsRoleGroupBy {
  id: [UsersPermissionsRoleConnectionId]
  _id: [UsersPermissionsRoleConnection_id]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsRoleConnectionId {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnection_id {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

type UsersPermissionsUser {
  id: ID!
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
  customerInfo: ComponentCustomerCustomer
  cart: Cart
  orders(sort: String, limit: Int, start: Int, where: JSON): [Order]
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsUserGroupBy {
  id: [UsersPermissionsUserConnectionId]
  _id: [UsersPermissionsUserConnection_id]
  createdAt: [UsersPermissionsUserConnectionCreatedAt]
  updatedAt: [UsersPermissionsUserConnectionUpdatedAt]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
  customerInfo: [UsersPermissionsUserConnectionCustomerInfo]
  cart: [UsersPermissionsUserConnectionCart]
}

type UsersPermissionsUserConnectionId {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnection_id {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCreatedAt {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUpdatedAt {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCustomerInfo {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCart {
  key: ID
  connection: UsersPermissionsUserConnection
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  customerInfo: ComponentCustomerCustomerInput
  orders: [ID]
  cart: ID
  created_by: ID
  updated_by: ID
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  customerInfo: editComponentCustomerCustomerInput
  orders: [ID]
  cart: ID
  created_by: ID
  updated_by: ID
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

type ComponentCartCartItem {
  id: ID!
  _id: ID!
  product: Product
  count: Int
}

input ComponentCartCartItemInput {
  product: ID
  count: Int
}

input editComponentCartCartItemInput {
  id: ID
  product: ID
  count: Int
}

type ComponentCustomerCustomer {
  id: ID!
  _id: ID!
  company: String
  phone: String
}

input ComponentCustomerCustomerInput {
  company: String
  phone: String
}

input editComponentCustomerCustomerInput {
  id: ID
  company: String
  phone: String
}

type ComponentPlacementPlacement {
  id: ID!
  _id: ID!
  balance: Int
  stock: Stock
}

input ComponentPlacementPlacementInput {
  balance: Int
  stock: ID
}

input editComponentPlacementPlacementInput {
  id: ID
  balance: Int
  stock: ID
}

type ComponentSaleProductDataSaleProductData {
  id: ID!
  _id: ID!
  product: Product
  count: Int
  sellingPrice: Float
}

input ComponentSaleProductDataSaleProductDatumInput {
  product: ID
  count: Int
  sellingPrice: Float
}

input editComponentSaleProductDataSaleProductDatumInput {
  id: ID
  product: ID
  count: Int
  sellingPrice: Float
}

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsLoginPayload | UserPermissionsPasswordPayload | Brand | BrandConnection | BrandAggregator | BrandGroupBy | BrandConnectionId | BrandConnection_id | BrandConnectionCreatedAt | BrandConnectionUpdatedAt | BrandConnectionName | BrandConnectionPhoto | createBrandPayload | updateBrandPayload | deleteBrandPayload | Cart | CartConnection | CartAggregator | CartGroupBy | CartConnectionId | CartConnection_id | CartConnectionCreatedAt | CartConnectionUpdatedAt | CartConnectionUser | createCartPayload | updateCartPayload | deleteCartPayload | Category | CategoryConnection | CategoryAggregator | CategoryGroupBy | CategoryConnectionId | CategoryConnection_id | CategoryConnectionCreatedAt | CategoryConnectionUpdatedAt | CategoryConnectionName | createCategoryPayload | updateCategoryPayload | deleteCategoryPayload | Consignment | ConsignmentConnection | ConsignmentAggregator | ConsignmentGroupBy | ConsignmentConnectionId | ConsignmentConnection_id | ConsignmentConnectionCreatedAt | ConsignmentConnectionUpdatedAt | ConsignmentConnectionName | ConsignmentConnectionProductionDate | ConsignmentConnectionValidUntil | ConsignmentConnectionCode_1c | ConsignmentConnectionProduct | ConsignmentConnectionPublished_at | createConsignmentPayload | updateConsignmentPayload | deleteConsignmentPayload | Contacts | updateContactPayload | deleteContactPayload | Group | GroupConnection | GroupAggregator | GroupGroupBy | GroupConnectionId | GroupConnection_id | GroupConnectionCreatedAt | GroupConnectionUpdatedAt | GroupConnectionName | GroupConnectionCategory | createGroupPayload | updateGroupPayload | deleteGroupPayload | Order | OrderConnection | OrderAggregator | OrderGroupBy | OrderConnectionId | OrderConnection_id | OrderConnectionCreatedAt | OrderConnectionUpdatedAt | OrderConnectionStatus | OrderConnectionUser | OrderConnectionInvoice | OrderConnectionRequestedShippingDate | OrderConnectionDeliveryInstruction | OrderConnectionPoNumber | createOrderPayload | updateOrderPayload | deleteOrderPayload | Product | ProductConnection | ProductAggregator | ProductAggregatorSum | ProductAggregatorAvg | ProductAggregatorMin | ProductAggregatorMax | ProductGroupBy | ProductConnectionId | ProductConnection_id | ProductConnectionCreatedAt | ProductConnectionUpdatedAt | ProductConnectionPn | ProductConnectionDescription_ru | ProductConnectionLongRead_ru | ProductConnectionUom | ProductConnectionCode_1c_uom | ProductConnectionColor | ProductConnectionMfg | ProductConnectionPrice_ru | ProductConnectionPrice_en | ProductConnectionPhoto | ProductConnectionCode_1c | ProductConnectionDescription_en | ProductConnectionLongRead_en | ProductConnectionGroup | ProductConnectionLink | ProductConnectionUnitDimension | ProductConnectionBrand | ProductConnectionSync1cDisplay | ProductConnectionDeletedFromSearch | ProductConnectionExpectedDeliveryDate | createProductPayload | updateProductPayload | deleteProductPayload | Stock | StockConnection | StockAggregator | StockGroupBy | StockConnectionId | StockConnection_id | StockConnectionCreatedAt | StockConnectionUpdatedAt | StockConnectionName | createStockPayload | updateStockPayload | deleteStockPayload | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileAggregatorSum | UploadFileAggregatorAvg | UploadFileAggregatorMin | UploadFileAggregatorMax | UploadFileGroupBy | UploadFileConnectionId | UploadFileConnection_id | UploadFileConnectionCreatedAt | UploadFileConnectionUpdatedAt | UploadFileConnectionName | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionWidth | UploadFileConnectionHeight | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | deleteFilePayload | UsersPermissionsPermission | UsersPermissionsRole | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnection_id | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsUser | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnectionId | UsersPermissionsUserConnection_id | UsersPermissionsUserConnectionCreatedAt | UsersPermissionsUserConnectionUpdatedAt | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | UsersPermissionsUserConnectionCustomerInfo | UsersPermissionsUserConnectionCart | createUserPayload | updateUserPayload | deleteUserPayload | ComponentCartCartItem | ComponentCustomerCustomer | ComponentPlacementPlacement | ComponentSaleProductDataSaleProductData

input InputID {
  id: ID!
}

enum PublicationState {
  LIVE
  PREVIEW
}

type AdminUser {
  id: ID!
  username: String
  firstname: String!
  lastname: String!
}

type Query {
  brand(id: ID!, publicationState: PublicationState): Brand
  brands(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Brand]
  brandsConnection(sort: String, limit: Int, start: Int, where: JSON): BrandConnection
  cart(id: ID!, publicationState: PublicationState): Cart
  carts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Cart]
  cartsConnection(sort: String, limit: Int, start: Int, where: JSON): CartConnection
  category(id: ID!, publicationState: PublicationState): Category
  categories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Category]
  categoriesConnection(sort: String, limit: Int, start: Int, where: JSON): CategoryConnection
  consignment(id: ID!, publicationState: PublicationState): Consignment
  consignments(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Consignment]
  consignmentsConnection(sort: String, limit: Int, start: Int, where: JSON): ConsignmentConnection
  contact(publicationState: PublicationState): Contacts
  group(id: ID!, publicationState: PublicationState): Group
  groups(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Group]
  groupsConnection(sort: String, limit: Int, start: Int, where: JSON): GroupConnection
  order(id: ID!, publicationState: PublicationState): Order
  orders(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Order]
  ordersConnection(sort: String, limit: Int, start: Int, where: JSON): OrderConnection
  product(id: ID!, publicationState: PublicationState): Product
  products(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Product]
  productsConnection(sort: String, limit: Int, start: Int, where: JSON): ProductConnection
  stock(id: ID!, publicationState: PublicationState): Stock
  stocks(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Stock]
  stocksConnection(sort: String, limit: Int, start: Int, where: JSON): StockConnection
  files(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UploadFile]
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!, publicationState: PublicationState): UsersPermissionsRole
  roles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsRole]
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsUser]
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
  countProductsInCart: Int
  getCart: Cart!
}

type Mutation {
  createBrand(input: createBrandInput): createBrandPayload
  updateBrand(input: updateBrandInput): updateBrandPayload
  deleteBrand(input: deleteBrandInput): deleteBrandPayload
  createCart(input: createCartInput): createCartPayload
  updateCart(input: updateCartInput): updateCartPayload
  deleteCart(input: deleteCartInput): deleteCartPayload
  createCategory(input: createCategoryInput): createCategoryPayload
  updateCategory(input: updateCategoryInput): updateCategoryPayload
  deleteCategory(input: deleteCategoryInput): deleteCategoryPayload
  createConsignment(input: createConsignmentInput): createConsignmentPayload
  updateConsignment(input: updateConsignmentInput): updateConsignmentPayload
  deleteConsignment(input: deleteConsignmentInput): deleteConsignmentPayload
  updateContact(input: updateContactInput): updateContactPayload
  deleteContact: deleteContactPayload
  createGroup(input: createGroupInput): createGroupPayload
  updateGroup(input: updateGroupInput): updateGroupPayload
  deleteGroup(input: deleteGroupInput): deleteGroupPayload
  createOrder(input: createOrderInput): createOrderPayload
  updateOrder(input: updateOrderInput): updateOrderPayload
  deleteOrder(input: deleteOrderInput): deleteOrderPayload
  createProduct(input: createProductInput): createProductPayload
  updateProduct(input: updateProductInput): updateProductPayload
  deleteProduct(input: deleteProductInput): deleteProductPayload
  createStock(input: createStockInput): createStockPayload
  updateStock(input: updateStockInput): updateStockPayload
  deleteStock(input: deleteStockInput): deleteStockPayload
  deleteFile(input: deleteFileInput): deleteFilePayload
  createRole(input: createRoleInput): createRolePayload
  updateRole(input: updateRoleInput): updateRolePayload
  deleteRole(input: deleteRoleInput): deleteRolePayload
  createUser(input: createUserInput): createUserPayload
  updateUser(input: updateUserInput): updateUserPayload
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, field: String, source: String, info: FileInfoInput, file: Upload!): UploadFile!
  multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!
  updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
  login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
  register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
  forgotPassword(email: String!): UserPermissionsPasswordPayload
  resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload
  emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
  addToCart(productId: ID!, count: Int): Cart!
  changeProductCountInCart(productId: ID!, count: Int!): Cart!
  deleteProductFromCart(productId: ID!): Cart!
  resetCart: Cart!
  createOrderFromCart(region: String!, requestedShippingDate: String, deliveryInstruction: String, poNumber: String): Order!
  requestQuote(id: ID!): String
}

scalar JSON

scalar DateTime

scalar Time

scalar Date

scalar Long

scalar Upload
